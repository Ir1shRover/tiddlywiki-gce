#!/bin/sh

# MIT License
# Copyright (c) 2018 Nicola Worthington <nicolaw@tfb.net>

# SSLCertificateFile /etc/letsencrypt/live/${DOMAIN}/cert.pem
# SSLCertificateKeyFile /etc/letsencrypt/live/${DOMAIN}/privkey.pem
# SSLCertificateChainFile /etc/letsencrypt/live/${DOMAIN}/fullchain.pem

set -ex

# Should we set DOMAIN to the external IP if it is not set?
#export DOMAIN="$(curl -H "Metadata-Flavor: Google" "http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/access-configs/0/external-ip")"

env

CONFPATH="/etc/letsencrypt"
LIVEPATH="$CONFPATH/live/$DOMAIN"
GLUEPATH="$CONFPATH/.glue"
HTDOCS="/usr/local/apache2/htdocs"

if [ ! -d "$LIVEPATH" ]; then
  mkdir -p "$LIVEPATH"
fi

if [ ! -d "$HTDOCS/.well-known" ]; then
  mkdir -p "$HTDOCS/.well-known"
fi

if [ ! -e "$GLUEPATH" ]; then
  mkdir -p "$GLUEPATH"
fi

cert_is_letsencrypt () {
  openssl x509 -in "$1" -text -noout 2>&1 \
    | grep -qEi "(letsencrypt\.org|Let.s Encrypt)"
}

domain_responds () {
  RC=1
  for try in 1 2 3 4 5
  do
    if [ -e "$HTDOCS/.well-known/tiddlywiki" ]; then
      MYSIG="$(cat "$HTDOCS/.well-known/tiddlywiki")"
    fi
    THEIRSIG="$(printf 'GET /.well-known/tiddlywiki\r\n\r\n' | nc "$1" 80)"
    if [ -n "$MYSIG" ] && [ -n "$THEIRSIG" ] && [ "$MYSIG" = "$THEIRSIG" ]; then
      RC=0
      break
    fi
    sleep 5
  done
  return $RC
}

# Generate a self-signed certificate until LetsEncrypt does it's thing.
if   [ ! -e "$LIVEPATH/cert.pem" ] \
  || [ ! -e "$LIVEPATH/privkey.pem" ] \
  || [ ! -e "$LIVEPATH/fullchain.pem" ]; then
  openssl req \
    -subj "/CN=$DOMAIN/O=$DOMAIN/OU=$DOMAIN/L=Location/ST=State/C=GB" \
    -new -newkey rsa:4096 -days 1180 -nodes -x509 \
    -keyout "$LIVEPATH/privkey.pem" \
    -out "$LIVEPATH/cert.pem"
  cp "$LIVEPATH/cert.pem" "$LIVEPATH/fullchain.pem"
fi

# Generate initial LetsEncrypt certificate.
if ! cert_is_letsencrypt "$LIVEPATH/cert.pem" \
  && domain_responds "$DOMAIN"; then
  echo "Generate LetsEncrypt certificate here."
  certbot certonly \
    --agree-tos \
    --non-interactive \
    --email "$EMAIL" \
    --config-dir "$GLUEPATH" \
    --webroot \
    --webroot-path "$HTDOCS" \
    --domains "$DOMAIN"

  # TODO: There is potential for a race condition here, so we should change this
  #       to replace the old self-signed certificate in a single atomic
  #       operation by changing a symbolic link. I think we're safe for the time
  #       being though, because we know that Apache is already running,
  #       otherwise certbot wouldn't have been able to finish the challenge
  #       response by using the Apache webroot.
  rm -Rf "$CONFPATH"/*
  mv "$GLUEPATH"/* "$CONFPATH"
  rm -Rf "$GLUEPATH"
  ln -sfn "$CONFPATH" "$GLUEPATH"
fi

# Display certificate information.
openssl x509 -in "$LIVEPATH/cert.pem" -text -noout

if ! cert_is_letsencrypt "$LIVEPATH/cert.pem"; then
  echo "Certificate $LIVEPATH/cert.pem is not from Let's Encrypt; gracefully exiting ..."
  exit 0
fi

# Launch cron daemon for LetsEncrypt to periodically refresh our certificate.
exec crond -l 6 -d 6 -f
